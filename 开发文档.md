# 协同代码编辑器组件开发文档

## 📋 项目概述

### 1.1 项目定位
本项目旨在开发一个**可嵌入式的协同代码编辑器组件**，而非独立的应用程序。该组件可以无缝集成到任何 Next.js 项目中，为宿主应用提供实时协同编码能力和代码运行环境。

### 1.2 核心特性
- **组件化架构**：完全模块化，可作为 React 组件直接引入
- **实时协同编辑**：多人同时编辑，所见即所得的协同体验
- **代码在线运行**：浏览器内运行代码，无需后端服务器编译
- **独立状态管理**：组件内部自治，不污染宿主应用状态
- **样式可定制**：基于 TailwindCSS 和 ShadcnUI，支持主题定制
- **零外部依赖**：所有服务自托管，无需第三方平台

### 1.3 应用场景
- 在线教育平台的代码教学模块
- 技术博客的交互式代码演示
- 代码审查和结对编程工具
- 企业内部知识库的代码示例展示
- 技术面试在线编码环境

---

## 🎯 技术选型分析

### 2.1 技术栈总览

#### 前端框架：Next.js 15.x（App Router）
**选型理由：**
- **同构渲染**：支持 SSR/SSG，提升首屏加载速度
- **API Routes**：内置后端能力，简化 WebSocket 服务器搭建
- **React 19 兼容**：使用最新的 React Server Components
- **文件路由**：组件化路由管理，便于模块拆分

**版本选择：** Next.js 15.0.0+（2024年10月发布的稳定版）

---

#### 协同引擎：Yjs 13.x 生态
**核心库组合：**
- `yjs@13.6.x`：CRDT 算法核心库
- `y-websocket@2.x`：WebSocket 通信层
- `y-monaco@0.1.x`：Monaco 编辑器绑定
- `y-protocols@1.x`：协同协议实现

**选型理由：**
- **无冲突算法**：基于 CRDT 的冲突自动解决
- **离线支持**：断线后自动同步增量更新
- **高性能**：支持百万级别的操作历史
- **去中心化**：可选 P2P 或中心化服务器模式
- **类型安全**：完整的 TypeScript 支持

**技术原理：**
Yjs 使用 YATA（Yet Another Transformation Approach）算法，通过逻辑时钟和因果关系链保证操作顺序一致性。每个字符都有唯一的 ID（客户端ID + 序列号），删除操作通过墓碑标记实现。

---

#### 代码运行环境：WebContainer API
**选型理由：**
- **浏览器内 Node.js**：完整的 Node.js 运行时，无需后端
- **文件系统模拟**：内存虚拟文件系统，支持 npm 包安装
- **进程隔离**：每个容器独立沙箱环境
- **性能优越**：基于 WebAssembly，接近原生性能

**技术限制：**
- 需要支持 SharedArrayBuffer（需要配置 COOP/COEP 头）
- 仅支持现代浏览器（Chrome 84+, Edge 84+）
- 不支持原生 Node.js 模块（如文件系统访问）

**使用版本：** `@webcontainer/api@1.3.x`

---

#### 状态管理：Zustand 4.x
**选型理由：**
- **轻量级**：仅 1KB，无额外依赖
- **无模板代码**：相比 Redux 更简洁
- **TypeScript 友好**：完整类型推导
- **组件隔离**：支持创建独立 store，不污染全局

**状态设计原则：**
- 编辑器状态（光标位置、选区、滚动位置）
- 协同状态（在线用户、用户操作历史）
- 运行时状态（容器实例、终端输出、构建状态）
- UI 状态（面板折叠、主题配置）

**版本：** `zustand@4.5.x`

---

#### UI 组件库：ShadcnUI + TailwindCSS
**ShadcnUI 特点：**
- **非 npm 包**：复制代码到项目，完全可控
- **基于 Radix UI**：无障碍访问（A11y）标准
- **可定制性强**：直接修改源码，无需覆盖样式

**TailwindCSS 配置：**
- 使用 `tailwindcss@3.4.x`（稳定版）
- 配置 JIT 模式，按需生成样式
- 自定义主题变量，支持明暗模式切换

**核心 UI 组件需求：**
- Resizable 分割面板（编辑器/预览区）
- Tabs 标签页（文件切换）
- Dropdown 下拉菜单（用户列表、设置）
- Dialog 对话框（分享链接、设置弹窗）
- Toast 通知（保存状态、错误提示）
- Avatar 头像（协同用户显示）

---

### 2.2 版本兼容性矩阵

```
Next.js 15.0.0
├── React 19.0.0 (内置依赖)
├── yjs 13.6.18
│   ├── y-websocket 2.0.4
│   ├── y-monaco 0.1.6
│   └── y-protocols 1.0.6
├── @webcontainer/api 1.3.3
├── zustand 4.5.5
├── monaco-editor 0.50.0
├── tailwindcss 3.4.14
└── @radix-ui/* (通过 shadcn 安装)
```

**冲突检查清单：**
✅ React 19 与 Yjs 生态兼容（已在 y-monaco 0.1.6 测试）
✅ Next.js 15 支持 Monaco Editor（通过动态导入避免 SSR 问题）
✅ Zustand 4.5.x 支持 React 19
✅ TailwindCSS 3.4.x 支持 Next.js 15

**注意事项：**
- Monaco Editor 必须使用动态导入（`next/dynamic`）禁用 SSR
- WebContainer 需要配置 Next.js 响应头（`crossOriginIsolation: true`）
- Yjs WebSocket 服务器需要自定义 Next.js API Route

---

## 🏗️ 架构设计

### 3.1 整体架构图（简化版 - 专注协同编辑 + 代码执行）

```
┌─────────────────────────────────────────────────────────┐
│                    宿主 Next.js 应用                      │
│  ┌─────────────────────────────────────────────────┐    │
│  │         <CodeEditor /> 协同编辑器组件             │    │
│  │  ┌──────────────────────────────────────────┐   │    │
│  │  │         Monaco Editor 编辑器层            │   │    │
│  │  │  ┌────────────────────────────────────┐  │   │    │
│  │  │  │   Y.Text (Yjs Shared Type)         │  │   │    │
│  │  │  │   ↓ y-monaco binding               │  │   │    │
│  │  │  │   Monaco Model                     │  │   │    │
│  │  │  └────────────────────────────────────┘  │   │    │
│  │  └──────────────────────────────────────────┘   │    │
│  │                                                  │    │
│  │  ┌──────────────────────────────────────────┐   │    │
│  │  │   WebContainer 运行时层 (简化版)          │   │    │
│  │  │  ┌────────────────────────────────────┐  │   │    │
│  │  │  │  仅执行 Node.js 脚本                │  │   │    │
│  │  │  │  ↓ 捕获 stdout/stderr              │  │   │    │
│  │  │  │  ↓ 输出到终端组件                   │  │   │    │
│  │  │  │  ❌ 无需启动 dev server              │  │   │    │
│  │  │  │  ❌ 无需 iframe 预览                 │  │   │    │
│  │  │  └────────────────────────────────────┘  │   │    │
│  │  └──────────────────────────────────────────┘   │    │
│  │                                                  │    │
│  │  ┌──────────────────────────────────────────┐   │    │
│  │  │      Zustand Store (组件状态)            │   │    │
│  │  │  - editorState                           │   │    │
│  │  │  - collaborationState                    │   │    │
│  │  │  - runtimeState (简化)                   │   │    │
│  │  │  - uiState                               │   │    │
│  │  └──────────────────────────────────────────┘   │    │
│  └─────────────────────────────────────────────────┘    │
│                          ↕                               │
│              WebSocket 连接 (Yjs 同步)                    │
│                          ↕                               │
│  ┌─────────────────────────────────────────────────┐    │
│  │     Next.js API Route: /api/collaboration       │    │
│  │  ┌──────────────────────────────────────────┐   │    │
│  │  │   Y-Websocket Server                     │   │    │
│  │  │   - 文档持久化 (可选数据库)                │   │    │
│  │  │   - 权限控制                              │   │    │
│  │  │   - 在线状态广播                           │   │    │
│  │  └──────────────────────────────────────────┘   │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘

📝 架构说明：
- ✅ 保留：协同编辑、文件管理、终端输出
- ⏸️ 暂缓：Preview Area、HMR、开发服务器
- 🎯 目标：类似 LeetCode 的代码执行 + 多人协同
```

---

### 3.2 数据流设计

#### 3.2.1 协同编辑数据流
```
用户 A 输入字符 'x'
  ↓
Monaco Editor onChange 事件
  ↓
y-monaco 自动同步到 Y.Text
  ↓
Yjs 生成操作（Operation）
  ↓
Y-Websocket 发送到服务器
  ↓
服务器广播给所有客户端
  ↓
用户 B 的 Yjs 接收操作
  ↓
Y.Text 更新
  ↓
y-monaco 自动更新 Monaco Editor
  ↓
用户 B 看到字符 'x'
```

**冲突解决示例：**
假设用户A和用户B同时在位置0插入：
- 用户A插入 'a' → 操作 O1: {clientID: A, clock: 1, insert: 'a', pos: 0}
- 用户B插入 'b' → 操作 O2: {clientID: B, clock: 1, insert: 'b', pos: 0}

Yjs CRDT 算法保证：
- 所有客户端最终收敛到相同状态
- 根据 clientID 字典序决定插入顺序（例如 A < B，结果为 "ab"）

---

#### 3.2.2 代码运行数据流
```
用户点击运行按钮
  ↓
Zustand Action: executeCode()
  ↓
从 Y.Map 读取文件系统状态
  ↓
同步到 WebContainer 虚拟文件系统
  ↓
WebContainer.spawn('npm', ['run', 'dev'])
  ↓
监听 stdout/stderr 流
  ↓
Zustand State: 更新 terminalOutput
  ↓
UI 组件订阅 Zustand → 渲染终端输出
  ↓
WebContainer 启动开发服务器（如 Vite）
  ↓
获取 iframe URL
  ↓
渲染预览窗口
```

---

### 3.3 模块划分

#### 核心模块结构（简化版）
```
src/
├── components/
│   ├── code-editor/                # 编辑器组件根目录
│   │   ├── index.tsx               # 导出入口
│   │   ├── Editor.tsx              # Monaco 编辑器包装
│   │   ├── FileTree.tsx            # 文件树组件
│   │   ├── Terminal.tsx            # 终端输出组件 ⭐ 核心
│   │   ├── UserCursors.tsx         # 协同光标组件
│   │   ├── Toolbar.tsx             # 工具栏组件
│   │   └── types.ts                # 组件类型定义
│   │
│   └── ui/                         # ShadcnUI 组件
│       ├── resizable.tsx
│       ├── tabs.tsx
│       ├── dropdown-menu.tsx
│       └── ...
│
├── lib/
│   ├── yjs/                        # Yjs 协同逻辑
│   │   ├── provider.ts             # Y-Websocket Provider 封装
│   │   ├── awareness.ts            # 用户状态同步
│   │   ├── fileSystem.ts           # 文件系统 CRDT 结构
│   │   └── undo-manager.ts         # 撤销/重做管理
│   │
│   ├── webcontainer/               # WebContainer 封装
│   │   ├── container.ts            # 容器实例管理
│   │   ├── fileSystem.ts           # 文件系统操作
│   │   ├── process.ts              # 进程管理
│   │   └── utils.ts                # 工具函数
│   │
│   ├── store/                      # Zustand Store
│   │   ├── index.ts                # Store 导出
│   │   ├── editor-store.ts         # 编辑器状态
│   │   ├── collaboration-store.ts  # 协同状态
│   │   ├── runtime-store.ts        # 运行时状态
│   │   └── ui-store.ts             # UI 状态
│   │
│   └── utils/                      # 工具函数
│       ├── monaco-config.ts        # Monaco 配置
│       ├── theme.ts                # 主题配置
│       └── logger.ts               # 日志工具
│
├── app/
│   ├── api/
│   │   └── collaboration/
│   │       └── route.ts            # WebSocket 服务器 API
│   │
│   └── demo/                       # 演示页面（可选）
│       └── page.tsx
│
├── hooks/                          # 自定义 Hooks
│   ├── useYjs.ts                   # Yjs 连接 Hook
│   ├── useWebContainer.ts          # WebContainer Hook
│   └── useCollaboration.ts         # 协同功能 Hook
│
└── types/                          # 全局类型定义
    ├── editor.ts
    ├── collaboration.ts
    └── webcontainer.ts
```

---

## 🔧 核心功能实现指南

### 4.1 Yjs 协同层实现

#### 4.1.1 数据结构设计
使用 Yjs 的 Shared Types 建立协同数据结构：

**文档结构：**
```typescript
YDoc
├── Y.Map<string, Y.Text> 'files'    // 文件内容
│   ├── 'src/index.tsx' → Y.Text
│   ├── 'package.json' → Y.Text
│   └── ...
│
├── Y.Map<string, any> 'metadata'    // 文件元数据
│   ├── 'activeFile' → string
│   ├── 'projectName' → string
│   └── ...
│
└── Awareness Protocol               // 用户状态
    ├── user1: { name, color, cursor, selection }
    ├── user2: { name, color, cursor, selection }
    └── ...
```

**设计原则：**
- 每个文件对应一个 Y.Text 对象（支持富文本协同）
- 使用 Y.Map 存储文件系统树结构（支持文件增删改）
- Awareness 存储临时状态（光标位置、在线状态）
- 文档级别唯一 ID（用于区分不同项目/房间）

---

#### 4.1.2 WebSocket 连接管理

**连接生命周期：**
1. **初始化阶段**
   - 组件挂载时创建 Y.Doc
   - 配置 WebSocket Provider（指向 Next.js API Route）
   - 设置断线重连策略（指数退避）

2. **同步阶段**
   - 首次连接：从服务器拉取完整文档快照
   - 增量同步：仅传输操作变更（压缩后通常 < 1KB）

3. **断开阶段**
   - 自动缓存未同步操作
   - 重连后自动发送缓存队列

**连接状态监听：**
- `synced`：已同步（显示绿色指示器）
- `connecting`：连接中（显示黄色加载动画）
- `disconnected`：断开（显示红色警告，启用只读模式）

---

#### 4.1.3 冲突解决策略

**类型级别的冲突处理：**

1. **文本编辑冲突（Y.Text）**
   - 自动合并：Yjs CRDT 算法保证无冲突
   - 示例：A 删除 "hello"，B 同时修改为 "HELLO" → 结果为删除操作生效

2. **文件操作冲突（Y.Map）**
   - 最后写入胜出（LWW - Last Write Wins）
   - 文件重命名冲突：使用时间戳后缀解决
   - 文件删除冲突：提供恢复功能（软删除标记）

3. **光标位置冲突（Awareness）**
   - 无冲突：每个用户独立状态
   - 仅广播，不持久化

---

### 4.2 Monaco Editor 集成

#### 4.2.1 编辑器初始化流程

**分步加载策略：**
1. 使用 `next/dynamic` 动态导入（避免 SSR 错误）
2. 配置 Monaco 语言支持（TypeScript, JavaScript, CSS, JSON）
3. 设置主题（Dark+/Light+/自定义）
4. 配置智能补全（TypeScript 类型定义）

**性能优化：**
- 懒加载语言定义文件（减少初始包体积）
- 使用 Web Worker 运行语法检查（避免主线程阻塞）
- 限制撤销历史记录数量（避免内存泄漏）

---

#### 4.2.2 与 Yjs 的绑定

**y-monaco 绑定流程：**
```
Monaco Model ←→ y-monaco Binding ←→ Y.Text
```

**关键实现：**
- 监听 Monaco `onDidChangeModelContent` 事件
- 将 Delta 转换为 Yjs 操作
- 监听 Y.Text `observe` 事件
- 将 Yjs 操作转换为 Monaco Delta

**光标同步实现：**
- 监听 Monaco `onDidChangeCursorPosition` 事件
- 更新 Awareness 协议中的 cursor 字段
- 订阅其他用户 Awareness 变化
- 在 Monaco 中渲染远程光标（使用 Decoration API）

**远程光标样式：**
- 位置指示器：垂直线条（用户颜色）
- 用户标签：悬浮显示用户名
- 选区高亮：半透明背景色

---

#### 4.2.3 智能补全增强

**TypeScript 类型定义加载：**
- 自动检测 package.json 中的依赖
- 从 CDN 加载 @types 定义（如 unpkg.com）
- 添加到 Monaco TypeScript Compiler Options

**自定义补全提供者：**
- 项目内文件路径补全
- 环境变量补全
- 自定义 snippet

---

### 4.3 WebContainer 集成（简化版 - 仅代码执行）

#### 4.3.1 容器初始化

**首次启动流程：**
1. 检查浏览器兼容性（SharedArrayBuffer 支持）
2. 配置 Next.js 响应头（COOP/COEP）
3. 调用 `WebContainer.boot()` 启动容器
4. 等待文件系统挂载完成

**文件系统同步：**
- 从 Y.Map 读取文件内容
- 写入 WebContainer 虚拟文件系统
- 监听 Y.Map 变化，自动同步文件更新

**初始化时间优化：**
- 预缓存 Node.js 运行时（IndexedDB）
- 延迟初始化（用户首次点击"运行"时才启动）

---

#### 4.3.2 代码执行流程（简化版）

**执行步骤：**
```
用户点击"运行"按钮
    ↓
读取当前打开的文件 (如 main.js)
    ↓
同步到 WebContainer 文件系统
    ↓
执行命令: node main.js
    ↓
捕获 stdout/stderr 实时输出
    ↓
显示在终端组件
    ↓
执行完成，显示耗时
```

**核心 API 使用：**
```typescript
// 执行代码
const process = await webContainer.spawn('node', ['main.js'])

// 监听输出
process.output.pipeTo(new WritableStream({
  write(chunk) {
    appendTerminalOutput(chunk) // 显示到终端
  }
}))

// 等待执行完成
const exitCode = await process.exit
if (exitCode !== 0) {
  showError('执行失败')
}
```

**错误处理：**
- 语法错误：显示 Node.js 错误信息和行号
- 运行时错误：显示完整堆栈跟踪
- 超时处理：超过 5 秒自动终止进程

**暂不实现：**
- ❌ npm 包安装（可选，后期添加）
- ❌ 多进程管理（暂时只支持单个执行）
- ❌ 开发服务器启动
- ❌ 热更新

---

#### 4.3.3 终端输出实现

**终端组件功能：**
- 实时显示 stdout（标准输出）
- 实时显示 stderr（错误输出）
- 区分普通输出和错误（不同颜色）
- 显示执行开始/结束时间
- 显示执行耗时
- 清空按钮
- 自动滚动到底部

**输出格式示例：**
```
$ node main.js
[1, 2, 3]
执行成功 (28ms)

$ node error.js
ReferenceError: x is not defined
    at Object.<anonymous> (error.js:1:13)
执行失败 (15ms)
```

**优化：**
- 限制输出行数（最多 1000 行，避免内存泄漏）
- 虚拟滚动（输出超过 100 行时使用）
- ANSI 颜色支持（可选）

---

### 4.4 Zustand 状态管理

#### 4.4.1 Store 设计原则

**模块化 Store：**
将状态按功能域拆分为独立 Store，通过组合使用：

```typescript
// 编辑器 Store
editorStore: {
  activeFile: string | null
  openFiles: string[]
  editorOptions: MonacoOptions
  actions: {
    openFile()
    closeFile()
    updateOptions()
  }
}

// 协同 Store
collaborationStore: {
  users: User[]
  yDoc: Y.Doc | null
  connectionStatus: 'connected' | 'connecting' | 'disconnected'
  actions: {
    connect()
    disconnect()
    updateUserInfo()
  }
}

// 运行时 Store
runtimeStore: {
  container: WebContainer | null
  processes: Process[]
  terminalOutput: string[]
  previewUrl: string | null
  actions: {
    bootContainer()
    runCommand()
    killProcess()
  }
}
```

**命名约定：**
- 状态名使用名词（`activeFile`）
- 动作名使用动词（`openFile`）
- 布尔值使用 `is/has` 前缀（`isRunning`）

---

#### 4.4.2 持久化策略

**选择性持久化：**
- 编辑器配置（主题、字体大小）→ localStorage
- 最近打开文件 → sessionStorage
- 运行时状态（进程、容器）→ 不持久化（临时）
- 协同状态（Yjs 文档）→ 服务器端持久化

**恢复机制：**
- 页面刷新后恢复编辑器配置
- 重新连接 WebSocket
- 重新启动 WebContainer

---

#### 4.4.3 性能优化

**选择器优化：**
- 使用浅比较选择器（避免不必要的重渲染）
- 拆分订阅（仅订阅需要的状态切片）

**批量更新：**
- 使用 `batch()` 合并多个状态更新
- 减少 React 重渲染次数

---

## 🎨 UI/UX 设计指南

### 5.1 布局结构（简化版 - 无预览窗口）

#### 5.1.1 双栏式布局
```
┌─────────────────────────────────────────────────┐
│  Toolbar (固定顶部 48px)                         │
│  [▶️ 运行] [⚙️ 设置] [👥 在线用户: 3]  [🔴 已连接] │
├─────────────┬───────────────────────────────────┤
│             │                                   │
│  File Tree  │   Editor Area (Monaco)            │
│  (可折叠)    │                                   │
│  240px      │   const arr = [1, 2, 2, 3]        │
│             │   console.log([...new Set(arr)])  │
│  📄 main.js │                                   │
│  📄 utils.js│                                   │
│             │                                   │
│             ├───────────────────────────────────┤
│             │  Terminal (终端输出)               │
│             │  (可折叠，默认展开)                 │
│             │  200px                            │
│             │                                   │
│             │  $ node main.js                   │
│             │  [1, 2, 3]                        │
│             │  ✅ 执行成功 (28ms)                 │
└─────────────┴───────────────────────────────────┘
```

**响应式设计：**
- 桌面端（>1024px）：双栏并排，终端在底部
- 平板端（768-1024px）：双栏，文件树可收起
- 移动端（<768px）：单栏，选项卡切换（编辑器/终端/文件）

**布局特点：**
- 重心在编辑器和终端，适合算法题、代码面试场景
- 终端默认展开，实时显示执行结果
- 无 Preview Area，减少视觉干扰

---

#### 5.1.2 面板可调整大小

使用 ShadcnUI `Resizable` 组件：
- 拖拽分隔线调整面板宽度
- 双击分隔线恢复默认尺寸
- 记住用户调整后的尺寸（localStorage）

---

### 5.2 协同感知元素

#### 5.2.1 用户在线列表
- 显示所有在线用户头像
- 头像边框颜色对应用户光标颜色
- 悬停显示用户名和最后活动时间
- 点击头像跟随其光标位置

#### 5.2.2 远程光标显示
- 光标颜色：每个用户分配唯一颜色（色相均匀分布）
- 光标标签：显示用户名，1 秒后自动隐藏
- 选区高亮：半透明背景，与光标颜色一致
- 淡出动画：用户离开时光标渐隐

#### 5.2.3 实时状态指示
- 保存指示器：自动保存（绿色对勾）/ 保存中（旋转动画）
- 连接状态：在线（绿点）/ 离线（红点）/ 同步中（黄点）
- 用户数量：实时显示当前在线人数

---

### 5.3 交互细节

#### 5.3.1 快捷键支持
- `Ctrl+S`：手动保存（虽然自动保存，但提供心理安慰）
- `Ctrl+/`：切换注释
- `Ctrl+B`：切换文件树显示
- `Ctrl+J`：切换终端显示
- `Ctrl+Shift+P`：命令面板
- `F5`：运行代码

#### 5.3.2 拖放功能
- 拖放文件到编辑器区域上传文件
- 拖动标签页重新排序
- 拖动文件树节点移动文件

#### 5.3.3 右键菜单
- 文件树右键：新建、重命名、删除、复制路径
- 编辑器右键：格式化代码、查找引用、转到定义
- 标签页右键：关闭、关闭其他、关闭全部

---

## 🔌 组件集成方案

### 6.1 导出方式

#### 6.1.1 单组件导出
```typescript
// 使用示例
import { CodeEditor } from '@/components/code-editor'

export default function MyPage() {
  return (
    <CodeEditor
      roomId="my-project-123"
      initialFiles={{
        'index.js': 'console.log("Hello World")'
      }}
      onSave={(files) => console.log('Saved', files)}
    />
  )
}
```

**Props 设计：**
- `roomId`：协同房间 ID（必需）
- `initialFiles`：初始文件结构
- `readOnly`：只读模式
- `theme`：主题（'dark' | 'light' | 'auto'）
- `height`：组件高度
- `onSave`：保存回调
- `onError`：错误回调
- `user`：当前用户信息（名称、头像）

---

#### 6.1.2 多组件拆分导出

允许宿主应用自定义布局：
```typescript
import { 
  EditorProvider,    // Context Provider
  FileTree,          // 文件树组件
  CodeEditor,        // 编辑器组件
  Terminal,          // 终端组件
  Preview,           // 预览组件
  UserList           // 用户列表组件
} from '@/components/code-editor'

export default function CustomLayout() {
  return (
    <EditorProvider roomId="my-room">
      <div className="flex">
        <FileTree />
        <CodeEditor />
        <div className="flex flex-col">
          <Preview />
          <Terminal />
        </div>
      </div>
      <UserList />
    </EditorProvider>
  )
}
```

---

### 6.2 配置管理

#### 6.2.1 全局配置文件
创建 `code-editor.config.ts` 配置文件：

```typescript
export default {
  // WebSocket 服务器地址
  wsUrl: process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3000/api/collaboration',
  
  // WebContainer 配置
  webcontainer: {
    enabled: true,
    coep: 'require-corp', // Cross-Origin-Embedder-Policy
  },
  
  // Monaco 配置
  monaco: {
    theme: 'vs-dark',
    fontSize: 14,
    tabSize: 2,
    minimap: { enabled: false },
  },
  
  // Yjs 配置
  yjs: {
    resyncInterval: 60000, // 60 秒
  },
  
  // UI 配置
  ui: {
    showFileTree: true,
    showTerminal: true,
    showPreview: true,
  },
}
```

---

#### 6.2.2 环境变量

`.env.local` 文件：
```bash
# WebSocket 服务器
NEXT_PUBLIC_WS_URL=ws://localhost:3000/api/collaboration

# 启用 WebContainer（需要配置 COOP/COEP 头）
NEXT_PUBLIC_ENABLE_WEBCONTAINER=true

# 持久化存储（可选）
DATABASE_URL=postgresql://...
```

---

### 6.3 样式定制

#### 6.3.1 TailwindCSS 主题扩展

在宿主应用的 `tailwind.config.js` 中扩展：
```typescript
module.exports = {
  theme: {
    extend: {
      colors: {
        'editor-bg': '#1e1e1e',
        'editor-fg': '#d4d4d4',
        'editor-line-number': '#858585',
        'editor-cursor': '#528bff',
      }
    }
  }
}
```

#### 6.3.2 CSS 变量覆盖

使用 CSS 变量实现主题定制：
```css
.code-editor {
  --editor-bg: #1e1e1e;
  --editor-fg: #d4d4d4;
  --toolbar-height: 48px;
  --file-tree-width: 240px;
}
```

宿主应用可覆盖：
```css
.my-custom-theme .code-editor {
  --editor-bg: #ffffff;
  --editor-fg: #000000;
}
```

---

## 📋 简化方案对比

### 6.1 完整版 vs 简化版对比

| 特性 | 完整版 | 简化版（当前） | 说明 |
|------|--------|---------------|------|
| **Monaco 编辑器** | ✅ | ✅ | 核心功能 |
| **Yjs 协同编辑** | ✅ | ✅ | 核心功能 |
| **文件树管理** | ✅ | ✅ | 核心功能 |
| **代码执行** | ✅ | ✅ | 核心功能 |
| **终端输出** | ✅ | ✅ | 核心功能 |
| **Preview 预览** | ✅ | ⏸️ 暂缓 | 未来扩展 |
| **开发服务器** | ✅ | ⏸️ 暂缓 | 未来扩展 |
| **HMR 热更新** | ✅ | ⏸️ 暂缓 | 未来扩展 |
| **npm 包管理** | ✅ | ⏸️ 暂缓 | 未来扩展 |
| **iframe 集成** | ✅ | ❌ 不需要 | 无需配置 |
| **COOP/COEP 头** | ⚠️ 必需 | ✅ 仍需要* | WebContainer 要求 |

\* WebContainer 本身仍需要 COOP/COEP 头，但配置更简单

---

### 6.2 简化带来的优势

#### 技术复杂度降低
- **无需处理 iframe 沙箱** - 减少 30% 安全相关代码
- **无需管理开发服务器** - 减少 40% 进程管理代码
- **无需实现 HMR** - 减少 20% 文件监听逻辑

#### 开发时间缩短
```
完整版: 8-12 周
    ↓ 简化
简化版: 5-7 周 (缩短 37%)
```

**各阶段耗时对比：**
- 迭代 1（编辑器）：1-2 周 → **不变**
- 迭代 2（协同）：2-3 周 → **不变**
- 迭代 3（运行时）：2-3 周 → **1-2 周** ⭐ 缩短
- 迭代 4（完善）：1-2 周 → **1 周**
- 迭代 5（封装）：1 周 → **不变**

#### 更聚焦的使用场景
✅ **适合的场景：**
- 在线编程考试（LeetCode/牛客网风格）
- 算法题练习平台
- JavaScript 基础教学
- 代码面试系统
- 函数逻辑验证

⚠️ **暂不适合的场景：**
- React/Vue 组件开发（需要预览）
- 完整项目原型开发（需要 HMR）
- UI 组件展示（需要可视化）

---

### 6.3 未来扩展路径

当项目稳定后，可以按以下顺序逐步添加功能：

#### 阶段 1：基础预览（+1 周）
```
添加 Preview Area
    ↓
支持 HTML 文件直接预览
    ↓
iframe 基础集成（无 HMR）
```

**适用场景：** HTML/CSS 静态页面预览

---

#### 阶段 2：开发服务器（+2 周）
```
集成 Vite 开发服务器
    ↓
启动虚拟 dev server
    ↓
提供 iframe 预览 URL
```

**适用场景：** React/Vue 单文件组件开发

---

#### 阶段 3：完整 HMR（+1 周）
```
监听文件变化
    ↓
触发 Vite HMR
    ↓
预览窗口无刷新更新
```

**适用场景：** 快速迭代原型开发

---

#### 阶段 4：包管理（+1 周）
```
解析 package.json
    ↓
WebContainer 执行 npm install
    ↓
支持第三方库
```

**适用场景：** 完整项目开发

---

### 6.4 技术债务最小化策略

通过以下方式确保未来扩展时不需要大规模重构：

#### 代码设计预留扩展点
```typescript
// runtimeStore.ts - 预留 preview 状态
interface RuntimeState {
  container: WebContainer | null
  terminalOutput: string[]
  // 预留字段（暂时不使用）
  previewUrl?: string  // 未来用于 Preview Area
  devServer?: {        // 未来用于开发服务器
    port: number
    status: 'running' | 'stopped'
  }
}
```

#### 组件结构预留位置
```typescript
// 布局组件 - 预留 Preview 插槽
<div className="editor-layout">
  <FileTree />
  <Editor />
  <Terminal />
  {/* 预留 Preview 位置 */}
  {enablePreview && <Preview />}
</div>
```

#### 配置开关控制功能
```typescript
// config.ts
export const features = {
  terminal: true,           // ✅ 当前启用
  preview: false,           // ⏸️ 暂时禁用
  devServer: false,         // ⏸️ 暂时禁用
  npmInstall: false,        // ⏸️ 暂时禁用
}
```

---

## 🚀 开发流程

### 7.1 项目初始化

#### 阶段 1：创建 Next.js 项目
1. 使用 `create-next-app` 脚手架（选择 App Router + TypeScript）
2. 配置 TailwindCSS（自动集成）
3. 安装 ShadcnUI CLI 并初始化
4. 配置 TypeScript `tsconfig.json`（启用严格模式）

#### 阶段 2：安装核心依赖
```bash
npm install yjs y-websocket y-protocols y-monaco
npm install @webcontainer/api
npm install zustand
npm install monaco-editor
npm install @monaco-editor/react
```

#### 阶段 3：配置 Next.js
1. 配置 `next.config.js` 支持 Monaco Editor（禁用 SSR）
2. 添加响应头支持 SharedArrayBuffer（COOP/COEP）
3. 配置 WebSocket 服务器 API Route

---

### 7.2 功能开发顺序

#### 迭代 1：基础编辑器（1-2 周）
**目标：** 实现单人可用的代码编辑器
- [ ] Monaco Editor 集成（语法高亮、智能补全）
- [ ] 文件树组件（创建、删除、重命名文件）
- [ ] 标签页系统（多文件切换）
- [ ] 基础工具栏（运行按钮、设置）
- [ ] Zustand Store 基础结构

**验收标准：**
- 可以打开、编辑、保存文件
- 支持 TypeScript/JavaScript 语法检查
- 文件树可以增删改查

---

#### 迭代 2：协同编辑（2-3 周）
**目标：** 实现多人实时协同
- [ ] Yjs 文档结构设计
- [ ] WebSocket 服务器实现（Next.js API Route）
- [ ] y-monaco 绑定（文本同步）
- [ ] Awareness 协议（光标同步）
- [ ] 远程光标渲染
- [ ] 在线用户列表
- [ ] 连接状态管理（断线重连）

**验收标准：**
- 两个浏览器窗口可以实时同步编辑
- 能看到对方的光标位置和选区
- 断网后自动重连并恢复同步

---

#### 迭代 3：代码执行（1-2 周）⭐ 简化版
**目标：** 实现浏览器内代码执行 + 终端输出
- [ ] WebContainer 初始化（仅 Node.js 运行时）
- [ ] 文件系统同步（Yjs ↔ WebContainer）
- [ ] 终端组件（显示命令输出）
- [ ] 执行 Node.js 脚本（`node main.js`）
- [ ] 捕获 stdout/stderr 输出
- [ ] 显示执行时间和状态
- [ ] 错误堆栈解析和定位

**验收标准：**
- 可以运行 JavaScript/TypeScript 代码
- 终端实时显示 console.log 输出
- 显示运行时错误和堆栈信息
- 显示执行时间（用于性能对比）

**暂不实现：**
- ❌ 开发服务器（Vite/Webpack）
- ❌ 预览窗口（iframe）
- ❌ HMR 热更新
- ❌ npm 包安装（可选，后期添加）

**适用场景：**
- ✅ 算法题练习（LeetCode 风格）
- ✅ JavaScript 基础教学
- ✅ 代码面试
- ✅ 函数逻辑测试

---

#### 迭代 4：功能完善（1-2 周）
**目标：** 增强用户体验
- [ ] 命令面板（快速操作）
- [ ] 搜索和替换（全局搜索）
- [ ] Git 集成（可选，显示文件变更状态）
- [ ] 主题切换（明暗模式）
- [ ] 快捷键系统
- [ ] 导出功能（下载项目 ZIP）
- [ ] 分享链接生成

**验收标准：**
- 用户体验流畅，无明显卡顿
- 快捷键覆盖常用操作
- 可以一键分享协同链接

---

#### 迭代 5：组件化封装（1 周）
**目标：** 可嵌入到任意 Next.js 项目
- [ ] 导出统一组件入口
- [ ] 完善 Props 和 TypeScript 类型
- [ ] 编写使用文档
- [ ] 创建示例项目
- [ ] 性能优化（代码分割、懒加载）
- [ ] 单元测试（核心逻辑）

**验收标准：**
- 可以通过一行代码集成到其他项目
- 组件有完整的 TypeScript 类型提示
- 文档清晰，包含所有 API 说明

---

### 7.3 测试策略

#### 7.3.1 单元测试
**测试框架：** Jest + React Testing Library

**重点测试模块：**
- Yjs 操作转换逻辑
- Zustand Store Actions
- 文件系统工具函数
- WebContainer 封装层

---

#### 7.3.2 集成测试
**测试场景：**
- 多客户端协同编辑一致性
- 断线重连后数据完整性
- WebContainer 运行不同类型项目
- 大文件编辑性能（>10000 行）

---

#### 7.3.3 端到端测试
**测试框架：** Playwright

**测试用例：**
- 用户 A 输入，用户 B 实时看到
- 用户 A 断线，用户 B 继续编辑，A 重连后同步
- 运行代码并验证预览窗口输出
- 创建、重命名、删除文件操作

---

## 📦 部署和集成

### 8.1 宿主应用集成步骤

#### 步骤 1：安装依赖
将编辑器组件作为项目内部模块（不发布为 npm 包）：
```bash
# 在宿主应用中
cp -r /path/to/code-editor/components/code-editor ./components/
cp -r /path/to/code-editor/lib ./lib
```

#### 步骤 2：配置 Next.js
复制必要的配置到宿主应用：
```javascript
// next.config.js
module.exports = {
  // 支持 Monaco Editor
  webpack: (config) => {
    config.module.rules.push({
      test: /\.worker\.js$/,
      use: { loader: 'worker-loader' }
    })
    return config
  },
  
  // 支持 WebContainer
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          { key: 'Cross-Origin-Embedder-Policy', value: 'require-corp' },
          { key: 'Cross-Origin-Opener-Policy', value: 'same-origin' },
        ],
      },
    ]
  },
}
```

#### 步骤 3：引入组件
```typescript
import { CodeEditor } from '@/components/code-editor'

export default function MyPage() {
  return (
    <CodeEditor
      roomId="my-project-123"
      initialFiles={{ 'index.js': 'console.log("Hello")' }}
    />
  )
}
```

---

### 8.2 服务器部署

#### 8.2.1 部署到 Vercel
**特殊配置：**
- 启用 WebSocket 支持（需要升级到 Pro 计划）
- 配置环境变量 `NEXT_PUBLIC_WS_URL`

**限制：**
- Vercel Serverless 函数不支持持久化 WebSocket
- 需要使用外部 WebSocket 服务器（如 Railway、Fly.io）

---

#### 8.2.2 自托管部署
**推荐方案：** Docker + Node.js

**Docker 配置：**
```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "start"]
```

**反向代理配置（Nginx）：**
```nginx
location /api/collaboration {
  proxy_pass http://localhost:3000;
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
}
```

---

### 8.3 数据持久化（可选）

#### 8.3.1 文档快照存储
**方案 1：PostgreSQL**
- 定期保存 Y.Doc 快照（每 5 分钟）
- 存储为二进制 Blob
- 查询时快速恢复

**方案 2：Redis**
- 实时同步文档更新
- 使用 TTL 自动清理过期文档
- 适合临时协同场景

#### 8.3.2 操作历史记录
- 记录每个操作的时间戳和用户
- 用于审计和版本回溯
- 存储为 JSON 格式（便于查询）

---

## 🔐 安全性考虑

### 9.1 访问控制
- **房间 ID 生成：** 使用 UUID v4（随机性）
- **权限验证：** WebSocket 连接前验证 JWT Token
- **只读模式：** 支持生成只读分享链接

### 9.2 代码执行安全
- **沙箱隔离：** WebContainer 自带沙箱，无法访问宿主文件系统
- **资源限制：** 限制内存使用（512MB）和 CPU 时间
- **网络隔离：** 禁止访问内网地址

### 9.3 数据安全
- **传输加密：** WebSocket 使用 WSS（TLS）
- **内容过滤：** 防止 XSS 攻击（Monaco 自动转义）
- **Rate Limiting：** API 限流（防止 DDoS）

---

## 🎯 性能优化清单

### 10.1 前端优化
- [ ] Monaco Editor 懒加载（用户打开编辑器时才加载）
- [ ] 虚拟滚动（文件树超过 1000 个节点）
- [ ] 代码分割（编辑器和预览窗口按路由拆分）
- [ ] 图片优化（用户头像使用 WebP）
- [ ] 防抖和节流（输入事件、窗口 resize）

### 10.2 后端优化
- [ ] WebSocket 消息压缩（Gzip）
- [ ] Y.Doc 增量同步（仅传输变更）
- [ ] 数据库索引优化（房间 ID 查询）
- [ ] CDN 缓存静态资源

### 10.3 网络优化
- [ ] WebSocket 心跳机制（30 秒 ping/pong）
- [ ] 断线重连指数退避（避免雪崩）
- [ ] 操作队列合并（批量发送）

---

## 📚 技术难点和解决方案

### 11.1 Monaco Editor SSR 问题
**问题：** Monaco Editor 依赖 DOM API，Next.js SSR 时报错

**解决：**
```typescript
import dynamic from 'next/dynamic'

const MonacoEditor = dynamic(
  () => import('@monaco-editor/react'),
  { ssr: false }
)
```

---

### 11.2 WebContainer SharedArrayBuffer 限制
**问题：** 浏览器需要 COOP/COEP 头才能启用 SharedArrayBuffer

**解决：**
在 `next.config.js` 中配置响应头：
```javascript
async headers() {
  return [{
    source: '/:path*',
    headers: [
      { key: 'Cross-Origin-Embedder-Policy', value: 'require-corp' },
      { key: 'Cross-Origin-Opener-Policy', value: 'same-origin' },
    ],
  }]
}
```

**限制：**
- 无法加载跨域资源（如外部字体、图片）
- 需要所有资源同源或配置 CORP

---

### 11.3 Yjs 大文档性能
**问题：** 文档操作超过 100 万次后同步变慢

**解决：**
- 定期压缩文档（删除墓碑标记）
- 使用子文档（subdocument）拆分大型项目
- 限制撤销历史记录（最多 1000 步）

---

### 11.4 WebSocket 连接数限制
**问题：** 浏览器单域名 WebSocket 连接数限制（通常 6 个）

**解决：**
- 使用单个 WebSocket 连接多路复用（Yjs 支持多文档复用）
- 为不同房间使用子协议（subprotocol）

---

## 🌟 扩展功能建议

### 12.1 近期扩展
- **语音通话：** 集成 WebRTC 实现语音协同
- **屏幕共享：** 展示操作过程
- **代码审查：** 添加评论和批注功能
- **版本历史：** 时间轴回溯代码变更
- **AI 补全：** 集成 GitHub Copilot 或本地模型

### 12.2 长期规划
- **移动端适配：** 响应式布局优化
- **插件系统：** 支持第三方扩展
- **Git 集成：** 完整的版本控制
- **多语言支持：** i18n 国际化
- **性能监控：** 实时协同延迟监测

---

## 📖 参考资源

### 官方文档
- Next.js: https://nextjs.org/docs
- Yjs: https://docs.yjs.dev/
- Monaco Editor: https://microsoft.github.io/monaco-editor/
- WebContainer: https://webcontainers.io/
- Zustand: https://zustand-demo.pmnd.rs/
- ShadcnUI: https://ui.shadcn.com/

### 开源项目参考
- CodeSandbox: https://github.com/codesandbox/codesandbox-client
- StackBlitz: https://blog.stackblitz.com/posts/webcontainers/
- Excalidraw: https://github.com/excalidraw/excalidraw (Yjs 协同案例)

### 技术博客
- Yjs CRDT 算法详解: https://blog.kevinjahns.de/
- WebContainer 技术原理: https://blog.stackblitz.com/
- Monaco Editor 最佳实践: https://github.com/microsoft/monaco-editor/wiki

---

## ✅ 开发检查清单

### 项目启动前
- [ ] 确认 Next.js 版本 >= 15.0.0
- [ ] 确认 Node.js 版本 >= 20.0.0
- [ ] 确认浏览器支持 SharedArrayBuffer
- [ ] 配置 TypeScript 严格模式
- [ ] 配置 ESLint 和 Prettier

### 功能开发中
- [ ] 每个组件编写 TypeScript 类型
- [ ] 每个核心函数编写单元测试
- [ ] 监听 Yjs 内存泄漏（定期 GC）
- [ ] 监控 WebSocket 连接状态
- [ ] 记录关键操作日志

### 上线前
- [ ] 完成端到端测试
- [ ] 性能测试（支持 10 人同时协同）
- [ ] 安全审计（XSS、CSRF 防护）
- [ ] 配置错误监控（Sentry）
- [ ] 编写用户使用文档

---


